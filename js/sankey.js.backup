/**
 * Sankey diagram visualization for wealth flow analysis
 * Shows the relationship between subjective and objective wealth classes
 */

// Color schemes matching geographical.js
const SUBJECTIVE_COLORS = {
    'ä¸‹å±¤éšç´š': '#a08080',      // æš—ç´…è¤
    'å‹å·¥éšç´š': '#c89090',      // æ·ºç´…è¤
    'ä¸­ä¸‹å±¤éšç´š': '#d4b896',    // æ·ºé»ƒè¤
    'ä¸­å±¤éšç´š': '#9db7c4',      // æ·ºè—ç°
    'ä¸­ä¸Šå±¤éšç´š': '#a8c4a8',    // æ·ºç¶ ç°
    'ä¸Šå±¤éšç´š': '#789078'       // æš—ç¶ ç°
};

const OBJECTIVE_COLORS = {
    'ä½': '#a08080',            // æš—ç´…è¤
    'ä¸­ä½': '#c89090',          // æ·ºç´…è¤
    'ä¸­ç­‰': '#d4b896',          // æ·ºé»ƒè¤
    'ä¸­é«˜': '#a8c4a8',          // æ·ºç¶ ç°
    'é«˜': '#789078'             // æš—ç¶ ç°
};

/**
 * Load and render Sankey diagram for a specific year
 * @param {string} year - Year to load (e.g., '1992', '1997')
 */
function loadSankeyDiagram(year) {
    console.log(`Loading Sankey diagram for ${year}...`);

    const containerId = `sankey-${year}`;
    const container = document.getElementById(containerId);

    if (!container) {
        console.error(`Container #${containerId} not found`);
        return;
    }

    // Show loading message
    container.innerHTML = '<p style="text-align: center; padding: 20px; color: #7f8c8d;">è¼‰å…¥ä¸­...</p>';

    // Load data
    d3.json(`data/processed/wealth_data_${year}.json`)
        .then(data => {
            renderSankeyDiagram(container, data, year);
        })
        .catch(error => {
            console.error(`Error loading Sankey data for ${year}:`, error);
            container.innerHTML = `<p style="text-align: center; padding: 20px; color: #e74c3c;">è¼‰å…¥å¤±æ•—ï¼š${error.message}</p>`;
        });
}

/**
 * Render Sankey diagram in the specified container
 * @param {HTMLElement} container - Container element
 * @param {Object} data - Wealth data with nodes and links
 * @param {string} year - Year label
 */
function renderSankeyDiagram(container, data, year) {
    // Clear container
    container.innerHTML = '';

    // Set up dimensions
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const width = container.clientWidth - margin.left - margin.right;
    const height = 600 - margin.top - margin.bottom;

    // Create SVG
    const svg = d3.select(container)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Create Sankey generator
    const sankey = d3.sankey()
        .nodeWidth(20)
        .nodePadding(15)
        .extent([[0, 0], [width, height]]);

    // Prepare data for d3-sankey
    // d3-sankey expects nodes as array with indices
    const nodeSet = new Set();
    data.links.forEach(link => {
        nodeSet.add(link.source);
        nodeSet.add(link.target);
    });

    const nodes = Array.from(nodeSet).map((name, index) => ({
        name: name,
        index: index
    }));

    const nodeMap = new Map(nodes.map(n => [n.name, n.index]));

    // Convert links to use indices
    const links = data.links.map(link => ({
        source: nodeMap.get(link.source),
        target: nodeMap.get(link.target),
        value: link.value,
        sourceName: link.source,
        targetName: link.target
    }));

    // Create sankey layout
    const graph = sankey({
        nodes: nodes.map(d => Object.assign({}, d)),
        links: links.map(d => Object.assign({}, d))
    });

    // Add links (flows)
    const link = svg.append('g')
        .selectAll('.sankey-link')
        .data(graph.links)
        .enter()
        .append('path')
        .attr('class', 'sankey-link')
        .attr('d', d3.sankeyLinkHorizontal())
        .attr('stroke', d => {
            // Color by source (subjective class)
            const sourceName = nodes[d.source.index].name;
            return SUBJECTIVE_COLORS[sourceName] || '#95a5a6';
        })
        .attr('stroke-width', d => Math.max(1, d.width))
        .attr('fill', 'none')
        .attr('opacity', 0.4)
        .on('mouseover', function(event, d) {
            d3.select(this).attr('opacity', 0.7);
            const sourceName = nodes[d.source.index].name;
            const targetName = nodes[d.target.index].name;
            showTooltip(
                `<strong>${sourceName}</strong> â†’ <strong>${targetName}</strong><br/>` +
                `äººæ•¸: ${d.value.toLocaleString()}<br/>` +
                `ä½”ç¸½æ¨£æœ¬: ${(d.value / data.total_samples * 100).toFixed(1)}%`,
                event.pageX,
                event.pageY
            );
        })
        .on('mouseout', function() {
            d3.select(this).attr('opacity', 0.4);
            hideTooltip();
        });

    // Add nodes (rectangles)
    const node = svg.append('g')
        .selectAll('.sankey-node')
        .data(graph.nodes)
        .enter()
        .append('g')
        .attr('class', 'sankey-node');

    node.append('rect')
        .attr('x', d => d.x0)
        .attr('y', d => d.y0)
        .attr('height', d => d.y1 - d.y0)
        .attr('width', d => d.x1 - d.x0)
        .attr('fill', d => {
            // Check if it's subjective or objective node
            if (SUBJECTIVE_COLORS[d.name]) {
                return SUBJECTIVE_COLORS[d.name];
            } else {
                return OBJECTIVE_COLORS[d.name] || '#95a5a6';
            }
        })
        .attr('stroke', '#34495e')
        .attr('stroke-width', 1)
        .on('mouseover', function(event, d) {
            d3.select(this).attr('opacity', 0.8);
            const isSubjective = SUBJECTIVE_COLORS[d.name];
            const category = isSubjective ? 'ä¸»è§€éšå±¤' : 'å®¢è§€è²¡å¯Œ';
            const summary = isSubjective ? data.summary.by_subjective : data.summary.by_objective;
            const total = summary[d.name] || d.value;

            showTooltip(
                `<strong>${category}: ${d.name}</strong><br/>` +
                `ç¸½äººæ•¸: ${total.toLocaleString()}<br/>` +
                `ä½”ç¸½æ¨£æœ¬: ${(total / data.total_samples * 100).toFixed(1)}%`,
                event.pageX,
                event.pageY
            );
        })
        .on('mouseout', function() {
            d3.select(this).attr('opacity', 1);
            hideTooltip();
        });

    // Add node labels
    node.append('text')
        .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
        .attr('y', d => (d.y1 + d.y0) / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
        .attr('font-size', '13px')
        .attr('font-weight', '500')
        .attr('fill', '#2c3e50')
        .text(d => d.name);

    // Add title
    svg.append('text')
        .attr('x', -10)
        .attr('y', -5)
        .attr('text-anchor', 'start')
        .attr('font-size', '14px')
        .attr('font-weight', 'bold')
        .attr('fill', '#2c3e50')
        .text('ä¸»è§€éšå±¤èªåŒ');

    svg.append('text')
        .attr('x', width + 10)
        .attr('y', -5)
        .attr('text-anchor', 'end')
        .attr('font-size', '14px')
        .attr('font-weight', 'bold')
        .attr('fill', '#2c3e50')
        .text('å®¢è§€ç¶“æ¿Ÿåœ°ä½');

    // Add summary statistics below the diagram
    const summaryDiv = d3.select(container)
        .append('div')
        .style('margin-top', '20px')
        .style('padding', '15px')
        .style('background-color', '#ecf0f1')
        .style('border-radius', '4px')
        .style('font-size', '14px');

    summaryDiv.append('p')
        .style('margin', '0 0 10px 0')
        .style('font-weight', 'bold')
        .html(`ğŸ“Š ${year}å¹´çµ±è¨ˆæ‘˜è¦ï¼ˆç¸½æ¨£æœ¬æ•¸: ${data.total_samples.toLocaleString()}ï¼‰`);

    // Subjective distribution
    const subjectiveStats = Object.entries(data.summary.by_subjective)
        .sort((a, b) => {
            const order = ['ä¸‹å±¤éšç´š', 'å‹å·¥éšç´š', 'ä¸­ä¸‹å±¤éšç´š', 'ä¸­å±¤éšç´š', 'ä¸­ä¸Šå±¤éšç´š', 'ä¸Šå±¤éšç´š'];
            return order.indexOf(a[0]) - order.indexOf(b[0]);
        })
        .map(([cls, count]) => `${cls}: ${count} (${(count / data.total_samples * 100).toFixed(1)}%)`)
        .join(' | ');

    summaryDiv.append('p')
        .style('margin', '5px 0')
        .html(`<strong>ä¸»è§€éšå±¤åˆ†å¸ƒ:</strong> ${subjectiveStats}`);

    // Objective distribution
    const objectiveStats = Object.entries(data.summary.by_objective)
        .sort((a, b) => {
            const order = ['ä½', 'ä¸­ä½', 'ä¸­ç­‰', 'ä¸­é«˜', 'é«˜'];
            return order.indexOf(a[0]) - order.indexOf(b[0]);
        })
        .map(([cls, count]) => `${cls}: ${count} (${(count / data.total_samples * 100).toFixed(1)}%)`)
        .join(' | ');

    summaryDiv.append('p')
        .style('margin', '5px 0 0 0')
        .html(`<strong>å®¢è§€è²¡å¯Œåˆ†å¸ƒ:</strong> ${objectiveStats}`);

    console.log(`Sankey diagram for ${year} rendered successfully`);
}

// Export function for use in main.js
window.loadSankeyDiagram = loadSankeyDiagram;
